String Hashing-Priyansh Agarwal- Priyansh Agarwal
Why String Hashing?●Optimizing Brute Force solutions●Comparing 2 strings●Daddy of String Algos
Requirements●If a == b, Hash(a) == Hash(b)●If a != b, Hash(a) != Hash(b)○If this is true with a very high probability we are good to go●Calculating Hash function should be fast enough●Hash of a string shouldn’t change in the code●Hash value should be itself O(1)
Polynomial Rolling Hash
Why Rolling? ●Hash(s) = H, what is Hash(s + x), x = character○(H + xpn) % m ●Hash(s) = H, what is Hash(x + s), x = character○(x + Hp) % m●How about calculating the Hash of a substring quickly?●How about just comparing two strings?
Pitfalls?●A != B but Hash(A) == Hash(b)○Probability = 1 / m●Comparing 50 such strings, probability of a collision = 50 / m●Let’s look at an example problem to see how it fails○Substring comparison problem●Solution????
String Hashing Template https://github.com/Priyansh19077/CP-Templates/blob/master/String%20Algorithms/String_Hashing.cpp 
Problem 1Given a string S of length N, find the number of distinct substrings present in the string.Examples:abc => 6aab => 5aaa => 3
Given a string S of length N (1 <= N <= 105) and Q (1 <= Q <= 105) queries where each query contains 2 integers L and R (1 <= L <= R <= N), find out for each query if the substring from L to R is a palindrome.Example:abccbd, q1 = [3, 4] => Yes, q2 = [1, 5] => No, q3 = [2, 4] => Yes
Problem 2Given a string S of length N (1 <= N <= 105), find out the longest substring which occurs at least twice in the string.Examples:abcdabcd => 4 (abcd)abbbbbbd => 5 (bbbbb)abccab => 2 (ab)
Problem 3Given a string S of length N (1 <= N <= 105), find out the longest palindromic substring.Examples:abbbbc => 4 (bbbb)abbabba => 7 (abbabba)abacde => 3 (aba)
Problem 4Priyansh19077/CP-TemplatesPublic
Priyansh19077corrected typo866cef1 · last yearHistoryNotificationsFork 
357 Star 
929CodeIssuesPull requests
1ActionsProjectsSecurityInsightsFiles master
Go to file
Common TechniquesGraph AlgorithmsNumber TheoryRange QueriesString AlgorithmsPrefix_Function.cppString_Hashing.cppSuffix_array.cppTrie.cppZAlgirthm.cppTemplateStuffTree Algorithms.gitignoreCP-Templates/String Algorithms/String_Hashing.cpp
struct Hashing{    string s;    int n;    int primes;    vector<ll> hashPrimes = {1000000009, 100000007};    const ll base = 31;    vector<vector<ll>> hashValues;    vector<vector<ll>> powersOfBase;    vector<vector<ll>> inversePowersOfBase;    Hashing(string a){        primes = sz(hashPrimes);        hashValues.resize(primes);        powersOfBase.resize(primes);        inversePowersOfBase.resize(primes);        s = a;        n = s.length();         for(int i = 0; i < sz(hashPrimes); i++) {            powersOfBase[i].resize(n + 1);            inversePowersOfBase[i].resize(n + 1);            powersOfBase[i][0] = 1;            for(int j = 1; j <= n; j++){                powersOfBase[i][j] = (base * powersOfBase[i][j - 1]) % hashPrimes[i];            }            inversePowersOfBase[i][n] = mminvprime(powersOfBase[i][n], hashPrimes[i]);            for(int j = n - 1; j >= 0; j--){                inversePowersOfBase[i][j] = mod_mul(inversePowersOfBase[i][j + 1], base, hashPrimes[i]);            }         }        for(int i = 0; i < sz(hashPrimes); i++) {            hashValues[i].resize(n);            for(int j = 0; j < n; j++){                hashValues[i][j] = ((s[j] - 'a' + 1LL) * powersOfBase[i][j]) % hashPrimes[i];                hashValues[i][j] = (hashValues[i][j] + (j > 0 ? hashValues[i][j - 1] : 0LL)) % hashPrimes[i];            }        }    }    vector<ll> substringHash(int l, int r){        vector<ll> hash(primes);        for(int i = 0; i < primes; i++){            ll val1 = hashValues[i][r];            ll val2 = l > 0 ? hashValues[i][l - 1] : 0LL;            hash[i] = mod_mul(mod_sub(val1, val2, hashPrimes[i]), inversePowersOfBase[i][l], hashPrimes[i]);        }        return hash;    }};struct Hashing{    string s;    int n;    int primes;    vector<ll> hashPrimes = {1000000009, 100000007};    const ll base = 31;    vector<vector<ll>> hashValues;    vector<vector<ll>> powersOfBase;    vector<vector<ll>> inversePowersOfBase;    Hashing(string a){        primes = sz(hashPrimes);        hashValues.resize(primes);        powersOfBase.resize(primes);        inversePowersOfBase.resize(primes);        s = a;        n = s.length();         for(int i = 0; i < sz(hashPrimes); i++) {            powersOfBase[i].resize(n + 1);            inversePowersOfBase[i].resize(n + 1);            powersOfBase[i][0] = 1;            for(int j = 1; j <= n; j++){                powersOfBase[i][j] = (base * powersOfBase[i][j - 1]) % hashPrimes[i];            }            inversePowersOfBase[i][n] = mminvprime(powersOfBase[i][n], hashPrimes[i]);            for(int j = n - 1; j >= 0; j--){                inversePowersOfBase[i][j] = mod_mul(inversePowersOfBase[i][j + 1], base, hashPrimes[i]);            }         }        for(int i = 0; i < sz(hashPrimes); i++) {            hashValues[i].resize(n);            for(int j = 0; j < n; j++){                hashValues[i][j] = ((s[j] - 'a' + 1LL) * powersOfBase[i][j]) % hashPrimes[i];                hashValues[i][j] = (hashValues[i][j] + (j > 0 ? hashValues[i][j - 1] : 0LL)) % hashPrimes[i];            }        }    }    vector<ll> substringHash(int l, int r){        vector<ll> hash(primes);        for(int i = 0; i < primes; i++){            ll val1 = hashValues[i][r];            ll val2 = l > 0 ? hashValues[i][l - 1] : 0LL;            hash[i] = mod_mul(mod_sub(val1, val2, hashPrimes[i]), inversePowersOfBase[i][l], hashPrimes[i]);        }        return hash;    }};1234567891011121314151617181920212223242526272829303132333435363738394041424344454646 lines (46 loc) · 1.77 KBCodeBlameRaw
Sign upProduct
Solutions
Resources
Open Source
Enterprise
PricingSign in22/02/25, 16:30Page 1 of 1